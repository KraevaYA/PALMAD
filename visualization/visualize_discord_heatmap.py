# -*- coding: utf-8 -*-
"""visualize_discord_heatmap.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mqSlJqAqQpJNaY4THur3NF3UxqS9tlGZ

# Import and install packages
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install -U kaleido

import numpy as np
import csv
import pandas as pd

import plotly
from plotly.subplots import make_subplots
from plotly.offline import init_notebook_mode
import plotly.graph_objs as go
import plotly.express as px
plotly.offline.init_notebook_mode(connected=False)

"""# Plots"""

def plot_ts(ts, n, title = "Input Time Series"):
    
    fig = go.Figure()
    
    fig.add_trace(go.Scatter(x=ts.index, y=ts.values.reshape(1,-1)[0]))

    fig.update_layout(title=title, 
                      xaxis_title='Time',
                      yaxis_title='Data values', width=2100)

    fig.show(renderer="colab")

def discords_plot(ts, discord_idx, m, topK):


    red_colors = [px.colors.sequential.Reds[8], px.colors.sequential.Reds[7], px.colors.sequential.Reds[6], px.colors.sequential.Reds[5], px.colors.sequential.Reds[3], px.colors.sequential.Reds[2]]
    blue_color = px.colors.qualitative.Plotly[0]

    plot_height = 300
    

    start_x = discord_idx - 150
    end_x = discord_idx + m + 150

    start_x = max(start_x, 0)
    end_x = min(end_x, len(ts))

    fig = go.Figure()

    fig.add_trace(go.Scatter(x=ts.index[start_x:end_x], y=list(ts.values.reshape(1,-1)[0][start_x:end_x]), line=dict(color=blue_color)))
    discord_end = min(discord_idx+m, len(ts))
    fig.add_trace(go.Scatter(x=ts.index[discord_idx:(discord_end)], y=list(ts.values.reshape(1,-1)[0][discord_idx:discord_end]), line=dict(color='red'))) #color=red_colors[topK],

    fig.update_xaxes(showgrid=False, linecolor='#000', mirror=True, ticks="outside", tickfont=dict(size=16), tickangle=0) 
    fig.update_yaxes(showgrid=False, linecolor='#000', mirror=True, ticks="outside", tickfont=dict(size=16), zeroline=False) 


   
    fig.update_layout(margin=dict(l=10, t=10, b=10, r = 10), height=plot_height, width=600, plot_bgcolor="#fff", showlegend=False)


    #fig.write_image("/content/drive/MyDrive/Research/ParMERLIN/plots/Huawei/ETTm2_discord_top" + str(top_k) + "_" + str(m)  + ".png", engine="kaleido")
    fig.write_image("/content/drive/MyDrive/Research/ParMERLIN/plots/Huawei/urban_traffic_speed/urban_traffic_speed_discord_top" + str(topK) + "_" + str(m)  + ".png", scale=3)
    #fig.show(renderer="colab")

def plot_ts_and_heatmap(ts, profiles, discords_ind, discords_m, file_name):
    
    red_colors = [px.colors.sequential.Reds[8], px.colors.sequential.Reds[7], px.colors.sequential.Reds[6], px.colors.sequential.Reds[5], px.colors.sequential.Reds[3], px.colors.sequential.Reds[2]]

    fig = make_subplots(rows=2, cols=1, subplot_titles=("<b>Time Series</b>", "<b>Discord Heatmap</b>"))

    fig.add_trace(go.Scatter(x=ts.index, y=ts.values.reshape(1,-1)[0], line=dict(color='#636EFA')), row=1, col=1)

    topK = 0

    # plot the anomaly red zones
    for length, discord_idx in zip(discords_m, discords_ind):
           fig.add_vrect(x0=str(ts.index[discord_idx]), x1=str(ts.index[discord_idx+length-1]), fillcolor='red', opacity=0.6, layer="below", line_width=0, row=1, col=1) #red_colors[topK]
           topK = topK + 1

    fig.add_trace(go.Heatmap(
                   z = profiles.iloc[0:profiles.shape[0]],
                   y = profiles.index.values,#[0:150],
                   x = ts.index[0:profiles.shape[1]],
                   hoverongaps = False,
                   colorscale = [[0, 'rgb(255,255,255, 1)'],
                                  [0.05, 'rgb(255,255,255, 1)'],
                                  [0.05, px.colors.sequential.Reds[0]],
                                  [0.24, px.colors.sequential.Reds[2]],
                                  [0.43, px.colors.sequential.Reds[3]],
                                  [0.62, px.colors.sequential.Reds[5]],
                                  [0.81, px.colors.sequential.Reds[6]],
                                  [1, px.colors.sequential.Reds[8]]
                   ],
                   colorbar = dict(thickness=20, outlinecolor='black', outlinewidth=0.5),
                   zmin=0, 
                   zmax=1
                   ), row=2, col=1)
    
    # make space for explanation / annotation
    fig.update_layout(margin=dict(l=10, r=10, b=10, t=80), plot_bgcolor="#fff", width=2200, coloraxis_showscale=False, showlegend=False)

    fig.update_xaxes(showgrid=False, linecolor='#000', mirror=True, ticks="outside", tickfont=dict(size=18)) 
    fig.update_yaxes(showgrid=False, linecolor='#000', mirror=True, ticks="outside", tickfont=dict(size=18), zeroline=False) 

    fig.layout.annotations[0].update(xanchor='left', x=0, y = 1.05, font=dict(size=20))
    fig.layout.annotations[1].update(xanchor='left', x=0, y = 0.42, font=dict(size=20))

    
    fig.for_each_xaxis(lambda axis: axis.title.update(font=dict(size=18)))
    fig.for_each_yaxis(lambda axis: axis.title.update(font=dict(size=18)))
                  
    fig.write_image("/content/drive/MyDrive/Research/ParMERLIN/plots/" + file_name, scale=3)

"""# Preprocess"""

def normalize_profiles(profiles, min_m, max_m):

    start_interval = 0.05
    end_interval = 1

    norm_profiles = []
    num_row = 0

    for m in range(min_m, max_m+1, 1):
    #for m in range(min_m, min_m+20, 1):
        
        profile = profiles.iloc[num_row:num_row+1].T

        row = range_discord_profiles.iloc[num_row]
        row = row.mask(row != -1, round(start_interval + (row/(2*m))*(end_interval-start_interval), 2))
        row = row.mask(row == -1, 0.0)

        num_row = num_row + 1
        norm_profiles.append(row)
        print(m)


    return norm_profiles

def normalize_discord_tbl(discords_tbl):

    discords_tbl['NNdist_norm'] = discords_tbl['NNdist'] / (2*discords_tbl['discord_length']).tolist()

    return discords_tbl

def find_max_nndist_profiles(profiles):

    max_profile = profiles.max(axis=0)
    max_nndist_lengths = profiles[::-1].idxmax(axis=0)

    return (max_profile, max_nndist_lengths)

def get_topk_interest_discords_from_tbl(discords_tbl, topk_discords):

    topK_index = []
    topK_m = []

    row = 0

    sort_discords_tbl = discords_tbl.sort_values(by=['NNdist_norm'], ascending=False)

    for i in range(topk_discords):

        j = 0

        while ((j < 1) and (row < len(sort_discords_tbl))):
            m = sort_discords_tbl['discord_length'].iloc[row]
            max_idx = sort_discords_tbl['discord_index'].iloc[row]

            #if (i < 3):
            #    print(f"length = {m}, ind = {max_idx}")
        
            if (len(topK_index) > 0):
                non_self_match = 0
                for k in range(len(topK_index)):
                    diff_subs = set(np.arange(max_idx, max_idx+m)) - set(np.arange(topK_index[k], topK_index[k]+topK_m[k]))
                    if (len(diff_subs) < m):
                    #if (abs(topK_index[k]-max_idx) < max(topK_m[k], m)):
                        non_self_match = 1
                        break
                if (non_self_match == 0):
                    topK_index.append(max_idx)
                    topK_m.append(m)
                    j = j + 1
            else:
                topK_index.append(max_idx)
                topK_m.append(m)
                j = j + 1

            row = row + 1


    return (topK_index, topK_m)

def get_topk_interest_discords(profile, max_lengths, topk_discords):


    topK_index = []
    topK_m = []

    row = 0

    sort_profile = profile.sort_index().sort_values(ascending=False, kind='stable')

    for i in range(topk_discords):

        j = 0

        while ((j < 1) and (row < len(profile))):
            max_idx = sort_profile.index[row]
            m = max_lengths.loc[max_idx]

            if (len(topK_index) > 0):
                non_self_match = 0
                for k in range(len(topK_index)):
                    diff_subs = set(np.arange(max_idx, max_idx+m)) - set(np.arange(topK_index[k], topK_index[k]+topK_m[k]))
                    if (len(diff_subs) < m):
                    #if (abs(topK_index[k]-max_idx) < max(topK_m[k], m)):
                        non_self_match = 1
                        break
                if (non_self_match == 0):
                    topK_index.append(max_idx)
                    topK_m.append(m)
                    j = j + 1
            else:
                topK_index.append(max_idx)
                topK_m.append(m)
                j = j + 1


            row = row + 1

    return (topK_index, topK_m)

"""# Case studies

### Time series

#### Read time series
"""

is_time_index = True

ts_path = '/content/drive/MyDrive/Research/ParMERLIN/datasets/for_Huawei/Urban_Traffic_Speed_Guangzhou/urban_traffic_speed_Guangzhou_with_time.csv'

if (is_time_index):
    ts = pd.read_csv(ts_path, index_col=0, header=None)
    # if intex type is datetime
    ts.index = pd.to_datetime(ts.index, dayfirst=True)
else:
    ts = pd.read_csv(ts_path, index_col=None, header=None)
n = len(ts)

#ts = ts.values.reshape(1,-1)[0]

"""#### Plot time series"""

plot_ts(ts, n)

"""### Range-discord profiles

#### Read the range-discord profiles
"""

profile_input_file = "/content/drive/MyDrive/Research/ParMERLIN/range_discord_profiles/Huawei/urban_traffic_speed_Guangzhou_72_288_top3.csv"

range_discord_profiles = pd.read_csv(profile_input_file, sep=";", index_col=0, header=None)

"""#### Normalize the range-discord profiles"""

min_m = range_discord_profiles.index[0]
max_m = range_discord_profiles.index[-1]

norm_profiles = normalize_profiles(range_discord_profiles, min_m, max_m)

"""### Maximum profile

#### Find the maximum profile and the corresponding lengths of discords where nndist is maximum among all lengths of T_i
"""

max_profile, max_nndist_lengths = find_max_nndist_profiles(pd.DataFrame(norm_profiles))

"""#### Plot the maximum profile"""

plot_ts(max_profile, len(max_profile))

"""### Find topk most interesting discords"""

topk_discords = 3

topk_discords_index, topk_discords_m = get_topk_interest_discords(max_profile, max_nndist_lengths, topk_discords)

topk_discord = 0
for discord_idx, discord_m in zip(topk_discords_index, topk_discords_m):
    print(f'Discord {topk_discord}: index = {discord_idx}, length = {discord_m}')
    topk_discord = topk_discord + 1

"""### Plot only discords"""

max_length = max(topk_discords_m)

topk_discord = 0
for m, discords_idx in zip(topk_discords_m, topk_discords_index):
    discords_plot(ts, discords_idx, m, topk_discord)
    topk_discord = topk_discord + 1

"""### Plot ts and heatmap"""

ts_and_heatmap_file_name = 'Huawei/urban_traffic_speed/ts_heatmap_urban_traffic_speed_72_288.png'
plot_ts_and_heatmap(ts, pd.DataFrame(norm_profiles), topk_discords_index, topk_discords_m, ts_and_heatmap_file_name)